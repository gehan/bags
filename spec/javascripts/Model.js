// Generated by CoffeeScript 1.3.1

(function() {
  var Collection, Model, done, flatten;
  Model = null;
  Collection = null;
  done = false;
  curl(['core/Model', 'core/Collection'], function(_Model, _Collection) {
    Model = _Model;
    Collection = _Collection;
    return done = true;
  });
  flatten = function(obj) {
    return JSON.encode(obj);
  };
  return describe("Model test", function() {
    var m;
    m = null;
    beforeEach(function() {
      waitsFor(function() {
        return done;
      });
      return m = new Model();
    });
    it('gets/sets attributes', function() {
      expect(m.has('test')).toBe(false);
      expect(m.get('test')).toBe(void 0);
      m.set('test', 'internet');
      expect(m.has('test')).toBe(true);
      return expect(m.get('test')).toBe('internet');
    });
    it('sets multiple attributes', function() {
      m.setMany({
        test: 'internet2',
        more: 'fecker'
      });
      expect(m.get('test')).toBe('internet2');
      return expect(m.get('more')).toBe('fecker');
    });
    it('gets/sets attributes', function() {
      var obj;
      obj = {
        k: 'val'
      };
      m = new Model({
        key: obj
      });
      return expect(m.get('key')).toBe(obj);
    });
    it('fires change event on attr change', function() {
      var changed, changedAKey;
      changed = {};
      m.addEvent('change', function(key, value) {
        return changed[key] = value;
      });
      changedAKey = null;
      m.addEvent('change:aKey', function(value) {
        return changedAKey = value;
      });
      m.setMany({
        aKey: 'internet',
        bKey: 'test'
      });
      expect(changed.aKey).toBe('internet');
      expect(changedAKey).toBe('internet');
      return expect(changed.bKey).toBe('test');
    });
    it('sets defaults silently when initializing model', function() {
      var changeFired;
      Model.implement({
        _defaults: {
          type: 'text',
          internet: 2,
          override: 'feck'
        }
      });
      changeFired = false;
      m = new Model({
        override: 'arse'
      }, {
        onChange: function() {
          return changeFired = true;
        }
      });
      expect(m.get('type')).toBe('text');
      expect(m.get('internet')).toBe(2);
      expect(m.get('override')).toBe('arse');
      expect(changeFired).toBe(false);
      Model.implement({
        _defaults: null
      });
      return Model.implement({
        _defaults: {}
      });
    });
    it('inits types correctly', function() {
      Model.implement({
        _types: {
          aDate: 'Date',
          aModel: function() {
            return Model;
          }
        }
      });
      m = new Model({
        aDate: '2012/01/01 02:02',
        aModel: {
          feck: 'arse'
        }
      });
      expect(instanceOf(m.get('aDate'), Date)).toBe(true);
      expect(m.get('aDate').format('%Y/%m/%d %H:%M')).toBe('2012/01/01 02:02');
      expect(instanceOf(m.get('aModel'), Model)).toBe(true);
      expect(m.get('aModel').get('feck')).toBe('arse');
      Model.implement({
        _types: null
      });
      return Model.implement({
        _types: {}
      });
    });
    it('inits type within arrays correctly', function() {
      Model.implement({
        _types: {
          aDate: 'Date'
        }
      });
      m = new Model({
        aDate: ['2012/01/01 02:02', '2012/01/01 02:03']
      });
      expect(m.get('aDate')[0].format('%Y/%m/%d %H:%M')).toBe('2012/01/01 02:02');
      expect(m.get('aDate')[1].format('%Y/%m/%d %H:%M')).toBe('2012/01/01 02:03');
      Model.implement({
        _types: null
      });
      return Model.implement({
        _types: {}
      });
    });
    it('sets id attribute when passed in', function() {
      m = new Model({
        id: 12
      });
      expect(m.get('id')).toBe(12);
      return expect(m.id).toBe(12);
    });
    it('sets custom id attribute when passed in', function() {
      Model.implement({
        _idField: "_id"
      });
      m = new Model({
        _id: 12
      });
      expect(m.get('_id')).toBe(12);
      expect(m.id).toBe(12);
      return Model.implement({
        _idField: "id"
      });
    });
    it('jsons basic key values', function() {
      var vals;
      vals = {
        key1: 'value1',
        key2: 'value2',
        key3: ['value3', 'value4']
      };
      m = new Model(vals);
      return expect(flatten(m.toJSON())).toBe(flatten(vals));
    });
    it('calls toJSON function on jsonable object', function() {
      var s, vals;
      s = {
        toJSON: function() {}
      };
      spyOn(s, 'toJSON').andReturn('value4');
      vals = {
        key1: 'value3',
        key2: s,
        key3: [s, s, s]
      };
      m = new Model(vals);
      return expect(flatten(m.toJSON())).toBe(flatten({
        key1: 'value3',
        key2: 'value4',
        key3: ['value4', 'value4', 'value4']
      }));
    });
    it('calls key-specific json methos on toJSON', function() {
      var Mdl, vals;
      Mdl = new Class({
        Extends: Model,
        jsonName: function(value) {
          return "json_" + value;
        }
      });
      vals = {
        key1: 'value1',
        name: 'value2'
      };
      m = new Mdl(vals);
      return expect(flatten(m.toJSON())).toBe(flatten({
        key1: 'value1',
        name: 'json_value2'
      }));
    });
    it('gives child model reference to itself', function() {
      var Mdl, mdl, subModel, vals;
      Mdl = new Class({
        Extends: Model,
        _types: {
          subModel: Model
        }
      });
      vals = {
        key1: 'value1',
        subModel: {
          key2: 'value2'
        }
      };
      mdl = new Mdl(vals);
      subModel = mdl.get('subModel');
      return expect(subModel.get('_parent')).toBe(mdl);
    });
    return it('instantiates a collection if set as type, adds to collections', function() {
      var Cll, Mdl, addedCollection, addedKey, mdl, vals, values;
      Cll = new Class({
        Extends: Collection,
        model: Model
      });
      Mdl = new Class({
        Extends: Model,
        _types: {
          subCollection: Cll
        }
      });
      values = [
        {
          id: 1,
          key: 'value'
        }, {
          id: 2,
          key: 'value'
        }
      ];
      vals = {
        subCollection: values
      };
      addedKey = null;
      addedCollection = null;
      mdl = new Mdl(vals, {
        onAddCollection: function(key, collection) {
          addedKey = key;
          return addedCollection = collection;
        }
      });
      expect(instanceOf(mdl.collections.subCollection, Cll)).toBe(true);
      expect(instanceOf(mdl.get('subCollection'), Cll)).toBe(true);
      expect(flatten(mdl.get('subCollection').toJSON())).toBe(flatten(values));
      expect(addedKey).toBe('subCollection');
      return expect(addedCollection).toBe(mdl.get('subCollection'));
    });
  });
})();
