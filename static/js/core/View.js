// Generated by CoffeeScript 1.3.1
var View;

View = new Class({
  Implements: [Options, Events, Templates],
  model: null,
  collection: null,
  el: null,
  events: {},
  template: null,
  options: {
    injectTo: null
  },
  initialize: function(options) {
    var key, _i, _len, _ref,
      _this = this;
    if (options == null) {
      options = {};
    }
    this.loadAllTemplates();
    _ref = ['collection', 'model', 'el', 'template'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (options[key] != null) {
        this[key] = options[key];
        delete options[key];
      }
    }
    if (this.model != null) {
      this.model.addEvent('remove', function() {
        return _this.destroy();
      });
    }
    this.setOptions(options);
    this.render();
    if (this.options.injectTo != null) {
      this.inject(this.options.injectTo);
    }
    return this;
  },
  /*
      Renders the element, if already rendered then
      replaces the current element
  */

  render: function(data) {
    var el;
    el = this._render(data);
    el.store('obj', this);
    if (!(this.el != null)) {
      this.el = el;
    } else {
      this._replaceCurrentEl(el);
    }
    Object.merge(this.refs, this.getRefs(el));
    this.delegateEvents(this.el, this.events);
    this.fireEvent('render');
    return el;
  },
  _replaceCurrentEl: function(el) {
    var _this = this;
    if (!instanceOf(el, Array)) {
      return this.el = el.replaces(this.el);
    } else {
      return this.el.each(function(currentEl, idx) {
        return _this.el[idx] = el[idx].replaces(currentEl);
      });
    }
  },
  /*
      Use to rerender a template partially, can be used to preserve
      visual state in template
  */

  rerender: function(refs, data) {
    var el,
      _this = this;
    el = this._render(data);
    return Array.from(refs).each(function(ref) {
      var newEl, replaceThis;
      replaceThis = _this.refs[ref];
      if (!replaceThis) {
        throw "Cannot find ref " + ref + " in template " + template;
      }
      newEl = _this.getRefs(el)[ref];
      Object.merge(_this.refs, _this.getRefs(newEl));
      return _this.refs[ref].replaces(replaceThis);
    });
  },
  _render: function(data) {
    var el;
    if (data == null) {
      data = this.parseForDisplay();
    }
    return el = this.renderTemplate(this.template, data);
  },
  inject: function() {
    var el, inDom, injectTo, parent;
    el = $(this);
    el.inject.apply(el, arguments);
    if (this.options.logInjects || true) {
      injectTo = arguments[0];
      inDom = false;
      parent = injectTo;
      if (parent === document.body) {
        inDom = true;
      }
      while (parent = parent.getParent()) {
        if (parent === document.body) {
          inDom = true;
        }
      }
      console.debug('inject ', el, ' into ', arguments[0], ' indom ', inDom);
    }
    return document.fireEvent('domupdated', [el]);
  },
  parseForDisplay: function() {
    if (this.model != null) {
      return this.model.toJSON();
    } else {
      return this.data;
    }
  },
  getElement: function() {
    return this.el.getElement.apply(this.el, arguments);
  },
  getElements: function() {
    return this.el.getElements.apply(this.el, arguments);
  },
  destroy: function() {
    return $(this).destroy();
  },
  toElement: function() {
    return this.el;
  }
});
